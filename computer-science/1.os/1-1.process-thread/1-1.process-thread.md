# 프로세스와 스레드
## 정의
### 프로세스
  - 실행 중인 프로그램
  - 운영체제로부터 자원을 할당받은 작업의 단위
  - 메모리에 적재되어 CPU를 할당받아 실행되고 있는 프로그램의 인스턴스

### 스레드
  - 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위
  - 프로세스 내에서 실행되는 독립적인 실행 흐름
  - CPU 스케줄링의 기본 단위

### 개인적인 정의
- 스프링으로 예시를 들었을 때 Tomcat이 하나의 프로세스가 되고, 스레드는 하나의 사용자 요청으로 볼 수 있음
- Tomcat은 여러 요청을 처리하기 위한 하나의 실행중인 프로그램(소스 코드)으로 볼 수 있고, 사용자 요청은 이 프로그램에서 일련의 과정을 수행하기 위한 단위라고 볼 수 있음

## 프로세스의 한계와 스레드 탄생
### 프로세스의 한계
- 생성/종료 비용이 너무 비쌈
  - 가상 메모리 할당, 영역 초기화, PCB 생성 및 초기화 등의 작업
- 메모리 낭비
  - 웹 브라우저를 기준으로 탭 1개당 별도 프로세스로 실행시 각 프로세스마다 코드 전체 복사
- 컨텍스트 스위칭 오버헤드
  - 프로세스 전환시 메모리 관리 전환(페이지 테이블 교체)이 필요, 스레드는 불필요함(같은 주소 공간이기 때문)
  - 페이지 테이블이란?
    - 페이지 테이블 = 가상 주소 → 물리 주소 변환표 / 물리 주소를 직접쓰면 보안이나 메모리 침범의 문제가 있음
    - 만약 물리 주소를 그대로 쓴다면 동일한 코드로 여러 개의 프로그램을 컴파일 할 때 각각 다른 메모리 주소를 할당해야함(메모리 주소를 관리해야함) 
    - 페이지 테이블은 OS에서 빈 물리 메모리를 찾아서 테이블에 맵핑시켜줌
- 프로세스 간 통신이 복잡하고 느림
  - 파이프, 공유 메모리, 메시지 큐 등의 작업이 필요함

### 스레드의 탄생으로 인한 해결
- 생성 비용 해결
  - Stack 만 새로 할당하면서 빨라짐
- 메모리 절약
  - Code, Data, Heap을 공유하기 때문에 독립적으로 생성되는 요소들이 적어지면서 메모리가 절약
- 빠른 컨텍스트 스위칭
  - 같은 주소 공간을 사용하기 때문에, 간단하게 얘기하면 Stack만 바꿔주면 됨 (컨텍스트 스위칭시)

## 메모리 구조 차이
### 프로세스
┌─────────────────┐
│   Code (Text)   │  ← 실행 코드
├─────────────────┤
│      Data       │  ← 전역 변수
├─────────────────┤
│      Heap       │  ← 동적 할당
├─────────────────┤
│      Stack      │  ← 지역 변수, 함수 호출
└─────────────────┘
- 각 프로세스는 완전히 독립된 메모리 공간을 가짐

### 스레드
┌─────────────────┐
│   Code (공유)    │  ← 모든 스레드가 공유
├─────────────────┤
│   Data (공유)    │  ← 모든 스레드가 공유
├─────────────────┤
│   Heap (공유)    │  ← 모든 스레드가 공유
├─────────────────┤
│  Thread 1 Stack │  ← 각 스레드 독립
├─────────────────┤
│  Thread 2 Stack │  ← 각 스레드 독립
├─────────────────┤
│  Thread 3 Stack │  ← 각 스레드 독립
└─────────────────┘
- 같은 프로세스 내 스레드들은 **Code, Data, Heap**을 공유하고 Stack만 독립적으로 가짐
- 하지만 이로써 생길 수 있는 문제는 동기화 문제가 있다.
  - 한 프로세스안에서의 스레드들은 전부 같은 Heap 데이터를 사용하기 때문에 Heap에 있는 데이터는 덮어씌워질 수 있다.

## 프로세스, 메모리 주요 차이점
| 특징       | 프로세스                 | 스레드                    |
|----------|----------------------|------------------------|
| 메모리 공간   | 독립적                  | 공유 (Stack만 독립)         |
| 생성 비용    | 높음 (수 ms)            | 낮음 (수 µs)              |
| 컨텍스트 스위칭 | 느림 (메모리 전환 필요)       | 빠름 (레지스터만 교체)          |
| 통신 방법    | IPC (파이프, 소켓, 공유메모리) | 공유 변수 직접 접근            |
| 안전성      | 독립적 (하나 죽어도 무관)      | 종속적 (하나 죽으면 전체 종료)     |
| 자원 소모    | 많음                   | 적음                     |
| 디버깅      | 상대적으로 쉬움             | 어려움 (Race condition 등) |

## 프로세스 또는 스레드는 왜 메모리에 올라가야할까?
### CPU의 특성
- CPU는 오직 메모리(RAM)에서만 명령어를 가져올 수 있음

┌─────────┐     ✓ 가능       ┌──────────┐
│   CPU   │ ←────────────── │  Memory  │
└─────────┘                 └──────────┘
↑
│ ✗ 불가능
│ (직접 접근 X)
┌─────────┐
│  Disk   │
└─────────┘

### 이유
1. CPU는 메모리 주소만 읽을 수 있음
   - Program Counter(PC)는 메모리 주소
   - 디스크는 완전히 다른 주소 체계
2. 속도 차이가 극심함
   - 메모리: 100ns
   - 디스크: 10,000,000ns
   - 디스크에서 직접 실행 = 사실상 불가능
3. 실행에 필요한 모든 것이 메모리 주소로 참조됨
   - 명령어 (Code)
   - 데이터 (Data, Heap)
   - 실행 상태 (Stack, 레지스터)
4. 메모리가 없으면 단 한 줄도 실행 불가
   CPU Cycle: Fetch(메모리) → Decode → Execute

## 프로세스 & 스레드의 동작 원리


## 프로세스 & 스레드 생명주기

